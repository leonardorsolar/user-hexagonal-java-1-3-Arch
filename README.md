# Tutorial 3: Refatora√ß√£o para Arquitetura Hexagonal

## Java Spring Boot + SQLite + Clean Architecture

### Sum√°rio Executivo

Este tutorial refatora o sistema CRUD de usu√°rios da **arquitetura em 3 camadas** para **Arquitetura Hexagonal** (tamb√©m conhecida como **Ports and Adapters** ou **Clean Architecture**), aplicando conceitos avan√ßados de **Domain-Driven Design (DDD)** e **princ√≠pios de Clean Code**.

Acesso ao c√≥digo em 3 camadas para iniciar o tutorial:
[Acesse o reposit√≥rio no GitHub](https://github.com/leonardorsolar/user-hexagonal-java-1-2-crud)

---

## Parte 1: Fundamentos da Arquitetura Hexagonal

### 1.1 O que √© Arquitetura Hexagonal?

A **Arquitetura Hexagonal** foi criada por **Alistair Cockburn**.
A Arquitetura Hexagonal, tamb√©m chamada de Ports and Adapters, √© um modelo de organiza√ß√£o de software que separa a l√≥gica de neg√≥cio (o n√∫cleo da aplica√ß√£o) das partes externas, como banco de dados, APIs e interface web.

Vamos visualizar forma de vermos a Arquitetura para entendermos melhor como aplic√°-la.

![Arquitetura Hexagonal](./docs/image/arquiteturahexagonal.png)

-   A regra de neg√≥cio fica no centro (n√∫cleo).

-   As interfaces externas (como controller, banco de dados, e-mail) se conectam ao n√∫cleo por meio de portas (interfaces) e adaptadores (implementa√ß√µes).

-   Isso facilita testes, manuten√ß√£o e troca de tecnologias.

üß† Exemplo simples:
Voc√™ pode trocar o banco de dados sem mudar a l√≥gica da aplica√ß√£o.

Pode testar tudo sem subir o servidor.

Vamos comprender mais a base desta arquitetura.

```
+---------------------+
|   InterfaceClasse  |  <<interface>>
+---------------------+
          ^
          |
+---------------------+
|     ClasseImpl     |  implements InterfaceClasse (classe concreta)
+---------------------+
```

## O que √© **implementar uma interface**?

√â criar uma classe que **segue esse contrato**, ou seja, define o comportamento dos m√©todos que foram apenas declarados na interface.

---

### üß© Exemplo da interface:

```java
public interface UsuarioService {
    UsuarioDTO criar(CreateUsuarioDTO dto);
    UsuarioDTO atualizar(Long id, UpdateUsuarioDTO dto);
    void deletar(Long id);
}
```

Essa interface define **o que deve ser feito**, mas **n√£o diz como**.

---

### üîß Exemplo da implementa√ß√£o:

```java
public class UsuarioServiceImpl implements UsuarioService {

    @Override
    public UsuarioDTO criar(CreateUsuarioDTO dto) {
        // Aqui voc√™ coloca a l√≥gica para criar um usu√°rio
    }

    @Override
    public UsuarioDTO atualizar(Long id, UpdateUsuarioDTO dto) {
        // Aqui voc√™ coloca a l√≥gica para atualizar um usu√°rio
    }

    @Override
    public void deletar(Long id) {
        // Aqui voc√™ coloca a l√≥gica para deletar um usu√°rio
    }
}
```

---

### ‚úÖ Resumo:

-   A **interface** √© o **contrato**: define _o que precisa ser feito_.
-   A **classe que implementa a interface** fornece a **l√≥gica real**: define _como isso ser√° feito_.

```
`  +---------------------+
  |      Controller      |  <- Adapter (classe concreta)
  | (UsuarioController)  |
  +----------+----------+
             |
             v
     +-----------------+
     |   Input Port    |  <- Interface
     | (UsuarioService)|
     +-------+---------+
             ^
             |
     +--------------------+
     |     **Core**       |  <- Implementa√ß√£o da l√≥gica (classe concreta)
     |(UsuarioServiceImpl)|
     +-------+------------+
             |
             v
    +--------------------+
    |  Output Port       |  <- Interface
    | (UsuarioRepository)|
    +-------+------------+
             ^
             |
  +-------------------------+
  |      Adapter            |
  | (UsuarioRepositoryImpl) |   <- Adapter (classe concreta)
  |     Database            |
  +--------------------------+`

```

### Observe aqui que o centro UsuarioServiceImpl (Core da aplica√ß√£o) aponta (usa) a classe de cima (UsuarioService) e aponta (usa) a classe de baixo (UsuarioRepository) e as classe que a core usa s√£o interfaces (contratos) e n√£o classe concretas.

---

-   **Controller (Adapter):** recebe requisi√ß√µes e chama o InputPort.
-   **InputPort (Interface):** define os m√©todos que o Controller usa.
-   **Core (Implementa√ß√£o):** a l√≥gica do servi√ßo implementa InputPort.
-   **OutputPort (Interface):** abstrai o acesso a dados.
-   **Adapter (Database):** implementa OutputPort para persist√™ncia real.

### üîÅ Diagrama **sem interfaces (acoplado)** para comparar:

```text
  +---------------------+
  |     Controller      |
  | (UsuarioController) | (classe concreta)
  +----------+----------+
             |
             v
     +--------------------+
     |     Service        |
     |(UsuarioServiceImpl)|  (classe concreta)
     +--------+-----------+
              |
              v
     +--------------------------+
     |     Repository Impl      |  (classe concreta)
     | (UsuarioRepositoryImpl)  |
     +--------------------------+
```

### üß® Problema aqui:

-   O `Controller` chama diretamente a implementa√ß√£o (`ServiceImpl`), que por sua vez chama diretamente o `RepositoryImpl`.
-   Isso **viola o DIP (Princ√≠pio da Invers√£o de Depend√™ncia)**.
-   Torna o sistema mais r√≠gido e dif√≠cil de testar.

---

### ‚úÖ J√° o primeiro diagrama:

-   Usa **interfaces entre as camadas**, garantindo **desacoplamento**.
-   Permite trocar implementa√ß√µes facilmente.
-   Favorece testes com _mocks_ e simula√ß√µes.

### Outra forma de visualizar o diagrama:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     WORLD OUTSIDE                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ   Web API    ‚îÇ  ‚îÇ   Database   ‚îÇ  ‚îÇ  External    ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  (Adapter)   ‚îÇ  ‚îÇ  (Adapter)   ‚îÇ  ‚îÇ   Services   ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ         ‚îÇ                 ‚îÇ                 ‚îÇ             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ Input Port   ‚îÇ  ‚îÇOutput Port   ‚îÇ  ‚îÇOutput Port   ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ(Interface)   ‚îÇ  ‚îÇ(Interface)   ‚îÇ  ‚îÇ(Interface)   ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ         ‚îÇ                 ‚îÇ                 ‚îÇ             ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ
‚îÇ                           ‚îÇ                               ‚îÇ
‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ    ‚îÇ           HEXAGON (CORE)                  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ                                           ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ         APPLICATION LAYER           ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ     (Use Cases / Services)          ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ                                     ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îÇ       DOMAIN LAYER          ‚îÇ    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îÇ   (Entities / Business)     ‚îÇ    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îÇ                             ‚îÇ    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ          ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Outra base para entender a arquitetura Hexagonal √© o conceito de Invers√£o de Depend√™ncia (ou Invers√£o de Controle)

## üß± Fundamento da Arquitetura Hexagonal: **Invers√£o de Depend√™ncia (DIP)**

Antes de entender a arquitetura Hexagonal, √© importante conhecer um conceito essencial chamado **Invers√£o de Depend√™ncia**, que tamb√©m √© conhecido como **Invers√£o de Controle**.

---

## üö¶ O que √© o DIP (Princ√≠pio da Invers√£o de Depend√™ncia)?

> O DIP diz que **as partes mais importantes do sistema (alto n√≠vel)** n√£o devem depender diretamente dos **detalhes t√©cnicos (baixo n√≠vel)**.
> Em vez disso, **ambos devem depender de uma interface (abstra√ß√£o)** que define o que precisa ser feito, mas n√£o como.

---

### üß† De forma simples:

-   **Alto n√≠vel** ‚Üí define **o que** o sistema deve fazer.
    Exemplo: a classe `UsuarioService`, onde est√° a l√≥gica de neg√≥cio.

-   **Baixo n√≠vel** ‚Üí cuida de **como** as coisas acontecem.
    Exemplo: `UsuarioRepository`, que salva os dados no banco.

---

## ü§ù Como eles se comunicam?

‚û°Ô∏è Atrav√©s de **interfaces** (ou contratos).
Assim, o c√≥digo principal do sistema **n√£o precisa conhecer os detalhes t√©cnicos**.

---

Vejamos mais um diagrama:

```
        +------------------------+
        |  UsuarioService        |  <- C√≥digo de alto n√≠vel
        |------------------------|
        | - usuarioRepository    |   <- Inje√ß√£o de depend√™ncia na classe UsuarioService
        +-----------+------------+
                    |
                    v
        +------------------------+
        |  UsuarioRepository     |  <- Interface (abstra√ß√£o - contrato)
        +-----------+------------+
                    ^
                    |
        +------------------------+
        | UsuarioRepositoryImpl  |  <- C√≥digo de baixo n√≠vel (implementa√ß√£o da interface)
        +------------------------+
```

Interpreta√ß√£o:

-   UsuarioService (n√≠vel alto) depende da interface UsuarioRepository, e n√£o sabe nem se importa com quem a implementa.
-   UsuarioRepositoryImpl (n√≠vel baixo) √© quem realmente implementa o contrato da interface e executa a a√ß√£o real de salvar.
-   Isso √© a ess√™ncia do DIP: alto e baixo n√≠vel n√£o se conhecem diretamente, e tudo depende de interfaces.

## ‚úÖ Exemplo pr√°tico no seu projeto:

```java
// Interface: contrato entre alto e baixo n√≠vel
public interface UsuarioRepository {
    void salvar(Usuario usuario);
}

// Baixo n√≠vel implementa esse contrato
public class UsuarioRepositoryImpl implements UsuarioRepository {
    public void salvar(Usuario usuario) {
        // l√≥gica que salva no banco de dados
    }
}

// Alto n√≠vel (servi√ßo) usa a interface, n√£o a implementa√ß√£o concreta
public class UsuarioService {
    private final UsuarioRepository usuarioRepository;

    public UsuarioService(UsuarioRepository usuarioRepository) {
        this.usuarioRepository = usuarioRepository;
    }

    public void registrarUsuario(Usuario usuario) {
        usuarioRepository.salvar(usuario); // n√£o importa como, apenas que funciona
    }
}
```

---

## üîå Analogia simples:

Imagine isso:

-   O celular √© o **controller** e precisa ser carregado.
-   O carregado **precisa de um carregador com entrada USB-C** (interface).
-   Qualquer carregador que tenha essa entrada serve, n√£o importa se √© da Samsung, Motorola, etc.
-   Algu√©m te entrega um carregador de qualquer marca (Samsung, Motorola...), desde que seja USB-C (implementa√ß√£o da interface).
-   O carregador real (implementa√ß√£o) √© o que executa a a√ß√£o: entregar energia
-   Voc√™ **n√£o precisa saber os detalhes**, s√≥ precisa saber que ele encaixa e funciona.

```
            +---------------------+
            |      Celular        |   <- Controller (quem solicita)
            |(Usu√°rio do sistema) |
            +---------+-----------+
                        |
                        v
            +--------------------+
            |     Entrada USB-C   |   <- Interface (abstra√ß√£o)
            | (Contrato esperado) |
            +---------+----------+
                        ^
            ____________|______________________
            |               |                |
            v               v                v
    +-----------+    +-----------+    +-------------+
    | Carregador|    | Carregador|    | Carregador  |
    | Samsung   |    | Motorola  |    | Gen√©rico    |
    +-----------+    +-----------+    +-------------+
(Impl. concreta)    (Impl. concreta)  (Impl. concreta)
```

### üß† Tradu√ß√£o para o c√≥digo:

| Analogia           | C√≥digo Spring Boot                    |
| ------------------ | ------------------------------------- |
| Celular            | `Controller`                          |
| Entrada USB-C      | `UsuarioService` (interface)          |
| Carregador Samsung | `UsuarioServiceImpl` (implementa√ß√£o)  |
| Energia fluindo    | `registrarUsuario()` (a√ß√£o executada) |

---

## An√°lise do lado esquerdo e direito da arquitetura

Em Arquitetura Hexagonal, o lado do "Driver" (Ator Prim√°rio) representa aqueles que iniciam a intera√ß√£o e s√£o sempre representados no lado esquerdo. O lado "Driven" (Ator Secund√°rio) corresponde aos atores que s√£o "acionados" pela aplica√ß√£o, ou seja, s√£o aqueles que a aplica√ß√£o chama.

![Arquitetura Hexagonal](./docs/image/ports_and_adapters.png)

### üß± **Centro: A Aplica√ß√£o**

-   O hex√°gono central √© a **l√≥gica principal do sistema** ‚Äî o **core** ou **dom√≠nio**.
-   Ela **n√£o conhece detalhes externos** como banco de dados, API, ou interface gr√°fica.

---

### üëâ **Lado esquerdo: Driver Side (Atores Prim√°rios)**

-   S√£o **os que iniciam a intera√ß√£o** com o sistema.
-   Ex.: usu√°rio humano, app web/mobile, testes automatizados, sistemas externos.
-   Se conectam com a aplica√ß√£o por meio de **portas de entrada (Input Ports)**.
-   Adaptadores t√≠picos: **Controllers, CLI, testes automatizados**.

---

### üëà **Lado direito: Driven Side (Atores Secund√°rios)**

-   S√£o **os que recebem comandos** da aplica√ß√£o.
-   Ex.: banco de dados, e-mail, impressora, mensageria.
-   S√£o acessados por meio de **portas de sa√≠da (Output Ports)**.
-   Adaptadores t√≠picos: **Reposit√≥rios, gateways, implementa√ß√µes t√©cnicas**.

---

| Termo           | Papel                                                             |
| --------------- | ----------------------------------------------------------------- |
| **Application** | N√∫cleo da aplica√ß√£o, isolado das tecnologias                      |
| **Driver Side** | Quem chama a aplica√ß√£o (ex.: Controller, User)                    |
| **Driven Side** | Quem √© chamado pela aplica√ß√£o (ex.: Banco de dados, SMTP)         |
| **Input Port**  | Interface usada para entrar no n√∫cleo                             |
| **Output Port** | Interface usada pelo n√∫cleo para se comunicar com o mundo externo |

### 1.2 Conceitos Fundamentais

#### **Ports (Portas)**

-   **Input Ports**: Interfaces que definem casos de uso
-   **Output Ports**: Interfaces que definem depend√™ncias externas

#### **Adapters (Adaptadores)**

-   **Primary Adapters**: Iniciam a√ß√µes (Controllers, CLI, etc.)
-   **Secondary Adapters**: Implementam funcionalidades (Database, APIs, etc.)

#### **Core (N√∫cleo)**

-   **Domain Layer**: Entidades e regras de neg√≥cio
-   **Application Layer**: Casos de uso e orquestra√ß√£o

### 1.3 Vantagens da Arquitetura Hexagonal

#### ‚úÖ **Desacoplamento Total**

-   Dom√≠nio independente de frameworks
-   F√°cil troca de tecnologias (database, web framework, etc.)

#### ‚úÖ **Testabilidade M√°xima**

-   Core pode ser testado sem infraestrutura
-   Mocks simples para adapters

#### ‚úÖ **Flexibilidade**

-   M√∫ltiplos adapters (REST API, GraphQL, CLI)
-   Diferentes bancos de dados (SQLite, PostgreSQL, MongoDB)

#### ‚úÖ **Manutenibilidade**

-   Regras de neg√≥cio centralizadas
-   Mudan√ßas de infraestrutura n√£o afetam o core

---

![Arquitetura Hexagonal](./docs/image/modelo.png)

## Parte 2: Estrutura da Arquitetura Hexagonal

Podemos ter v√°rias forma de organizar as pastas do projeto. vamos ver isso:

## üü® Estrutura 1 com `adapters` e `application`

![Arquitetura Hexagonal](./docs/image/aplicaAdp.png)

```text
src/
‚îú‚îÄ‚îÄ adapters/                             # üîå Adaptadores que conectam o mundo externo ao sistema
‚îÇ   ‚îú‚îÄ‚îÄ inbound/                          # ‚Ü©Ô∏è Entrada: recebe requisi√ß√µes externas (ex: APIs, controllers)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ controller/                   #    ‚îî‚îÄ‚îÄ Controladores REST ou HTTP que iniciam os casos de uso
‚îÇ   ‚îî‚îÄ‚îÄ outbound/                         # ‚Ü™Ô∏è Sa√≠da: comunica com sistemas externos (ex: banco de dados, servi√ßos)
‚îÇ       ‚îî‚îÄ‚îÄ repository/                   #    ‚îî‚îÄ‚îÄ Implementa√ß√µes de persist√™ncia (ex: JPA, Mongo, JDBC)

‚îú‚îÄ‚îÄ application/                          # üß† L√≥gica de aplica√ß√£o (casos de uso e orquestra√ß√£o)
‚îÇ   ‚îú‚îÄ‚îÄ core/                             #    üîÅ N√∫cleo da aplica√ß√£o (sem depend√™ncias externas)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/                       #     ‚öôÔ∏è Implementa√ß√µes dos casos de uso (ex: CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ domain/                       #       Entidades de neg√≥cio e regras do dom√≠nio
‚îÇ   ‚îî‚îÄ‚îÄ ports/                            #    üö™ Interfaces que definem os contratos da aplica√ß√£o
‚îÇ       ‚îú‚îÄ‚îÄ in/                           #       ‚Ü©Ô∏è Portas de entrada: contratos dos casos de uso
‚îÇ       ‚îî‚îÄ‚îÄ out/                          #       ‚Ü™Ô∏è Portas de sa√≠da: contratos com infraestrutura (repos, servi√ßos)

```

## üü® Estrutura 2 com `domain` , `application` e `infrastructure`

![Arquitetura Hexagonal](./docs/image/domaplInf.png)

Reflete os n√≠veis l√≥gicos da aplica√ß√£o (dom√≠nio ‚Üí aplica√ß√£o ‚Üí infraestrutura).
Facilita a visualiza√ß√£o da separa√ß√£o de responsabilidades (DDD + Hexagonal + Clean Architecture)
Adapta-se melhor √† modulariza√ß√£o por dom√≠nio, caso o sistema cres√ßa.
Mais flex√≠vel para projetos reais

```text
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java               # üöÄ Classe principal que inicia a aplica√ß√£o Spring Boot
‚îÇ
‚îú‚îÄ‚îÄ user/                                   # üßç M√≥dulo de Usu√°rio (Feature modularizada isoladamente)
‚îÇ   ‚îú‚îÄ‚îÄ domain/                             # üß† N√∫cleo do dom√≠nio do usu√°rio (regra de neg√≥cio pura)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ model/                          #     üì¶ Entidades do dom√≠nio (ex: Usuario.java)
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ application/                        # üí° Camada de aplica√ß√£o (orquestra os casos de uso)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/                           #     üö™ Portas: interfaces que exp√µem (input) e consomem (output) funcionalidades
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/                      #       ‚Ü©Ô∏è Casos de uso oferecidos ao mundo externo (ex: CriarUsuarioUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/                     #       ‚Ü™Ô∏è Contratos com servi√ßos externos (ex: UsuarioRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/                        #     ‚öôÔ∏è Implementa√ß√µes dos casos de uso (ex: CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/                            #     üì§ Objetos de transfer√™ncia de dados (ex: CreateUsuarioDTO, UpdateUsuarioDTO)
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/                     # üõ†Ô∏è Implementa√ß√µes concretas de acesso externo (adaptadores e configura√ß√µes)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/                        #     üîå Adaptadores conectando o dom√≠nio com o mundo externo
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/                  #       üåê Adaptadores de entrada (ex: REST Controllers)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UsuarioController.java  #         ‚Üí Recebe requisi√ß√µes HTTP e chama os casos de uso
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/         #       üóÑÔ∏è Adaptadores de sa√≠da (ex: banco de dados, via JPA)
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioRepositoryAdapter.java #   ‚Üí Implementa a interface de reposit√≥rio definida na camada de aplica√ß√£o
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ encoder/, email/                #     üîê Servi√ßos externos (ex: codificador de senha, envio de e-mail)
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ mapper/                             # üîÑ Conversores entre entidades, DTOs e objetos de persist√™ncia
‚îÇ       ‚îî‚îÄ‚îÄ UsuarioMapper.java
‚îÇ
‚îú‚îÄ‚îÄ shared/                                 # üì¶ C√≥digo gen√©rico e reutiliz√°vel entre m√≥dulos
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ (DatabaseConfig.java, BeanConfig.java) # ‚öôÔ∏è Configura√ß√µes globais da aplica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ exception/                                 # ‚ùó Tratamento de exce√ß√µes gen√©ricas da aplica√ß√£o
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GlobalExceptionHandler.java
‚îÇ   ‚îî‚îÄ‚îÄ util/                                      # üß∞ Utilit√°rios diversos compartilhados entre m√≥dulos

```

Resumo das vantagens dessa estrutura:
Altamente did√°tica: cada camada e m√≥dulo tem seu espa√ßo e responsabilidade.
Organiza√ß√£o modular (por feature): permite escalar para v√°rios dom√≠nios como account/, product/, etc.
Segrega√ß√£o limpa entre dom√≠nio, aplica√ß√£o e infraestrutura.
Facilita testes, manuten√ß√£o e colabora√ß√£o entre times.

### ‚úÖ Estrutura Modular por M√≥dulo / Feature ( m√≥dulo User)

```text
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java
‚îú‚îÄ‚îÄ user/                              # üßç M√≥dulo de Usu√°rio
‚îÇ   ‚îú‚îÄ‚îÄ domain/                        # ‚Üê CORE do m√≥dulo usu√°rio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/ (Usuario.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/ (CriarUsuarioUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/ (UsuarioRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/ (CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/ (UsuarioController.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioRepositoryAdapter.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntity.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ encoder/, email/
‚îÇ   ‚îî‚îÄ‚îÄ mapper/ (UsuarioMapper.java)
‚îÇ
‚îú‚îÄ‚îÄ shared/                            # üì¶ C√≥digo compartilhado (se necess√°rio)
‚îÇ   ‚îú‚îÄ‚îÄ config/ (DatabaseConfig.java, BeanConfig.java)
‚îÇ   ‚îú‚îÄ‚îÄ exception/ (GlobalExceptionHandler.java)
‚îÇ   ‚îî‚îÄ‚îÄ util/
```

-   **Modulariza√ß√£o por m√≥dulo de neg√≥cio (ex: `user`)**: Cada m√≥dulo √© praticamente um "mini hex√°gono" isolado, com seu pr√≥prio dom√≠nio, aplica√ß√£o e infraestrutura.
-   **Foco na organiza√ß√£o modular**: Tudo referente ao usu√°rio fica dentro do m√≥dulo `user/`.
-   **Separa claramente as camadas dentro do m√≥dulo**:

    -   `domain/` (modelo e regras do dom√≠nio do usu√°rio)
    -   `application/` (casos de uso, servi√ßos, portas)
    -   `infrastructure/` (adaptadores de entrada e sa√≠da, implementa√ß√µes concretas)

-   **`shared/` para c√≥digo comum entre m√≥dulos** (configura√ß√µes, utilit√°rios, exce√ß√µes globais)

**Resumo:** Organiza√ß√£o por m√≥dulos de neg√≥cio (exemplo: m√≥dulo `user`), onde cada m√≥dulo √© auto-contido e tem as camadas hexagonais internamente.

### ‚úÖ Estrutura com M√≥dulos: `user` e `account`

```text
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java
‚îú‚îÄ‚îÄ user/                              # üßç M√≥dulo de Usu√°rio
‚îÇ   ‚îú‚îÄ‚îÄ domain/                        # ‚Üê CORE do m√≥dulo usu√°rio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/ (Usuario.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/ (CriarUsuarioUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/ (UsuarioRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/ (CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/ (UsuarioController.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioRepositoryAdapter.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntity.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ encoder/, email/
‚îÇ   ‚îî‚îÄ‚îÄ mapper/ (UsuarioMapper.java)
‚îÇ
‚îú‚îÄ‚îÄ account/                           # üè¶ M√≥dulo de Conta Banc√°ria
‚îÇ   ‚îú‚îÄ‚îÄ
‚îÇ
‚îú‚îÄ‚îÄ shared/                            # üì¶ C√≥digo compartilhado (se necess√°rio)
‚îÇ   ‚îú‚îÄ‚îÄ config/ (DatabaseConfig.java, BeanConfig.java)
‚îÇ   ‚îú‚îÄ‚îÄ exception/ (GlobalExceptionHandler.java)
‚îÇ   ‚îî‚îÄ‚îÄ util/
```

Deste que utizemos a invers√£o de depend√™ncia podemos estruturar as pastas da nossa maneira.

-   Core (Dom√≠nio): √© o cora√ß√£o da aplica√ß√£o. N√£o conhece o banco, nem o Spring. Cont√©m a l√≥gica pura.
-   Application Layer: orquestra os casos de uso. Usa interfaces (ports) para se comunicar com o mundo externo.
-   Infrastructure: √© o mundo externo ‚Äî onde ficam os detalhes concretos (Web, Banco de Dados, Email...).
-   Adapters: ligam o mundo externo (Infra) ao core, implementando as interfaces da camada de aplica√ß√£o.

### Estrutura Separa√ß√£o por Camadas Globais sem modulariza√ß√£o expl√≠cita

Separa√ß√£o maior de responsabilidades. Aqui temos o dom√≠nio rico, com a regras de neg√≥cio separada da aplica√ß√£o.

```bash
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java          # Classe principal (Spring Boot)
‚îÇ
‚îú‚îÄ‚îÄ domain/                            # üí† N√∫cleo (Dom√≠nio - Core do Hex√°gono)
‚îÇ   ‚îú‚îÄ‚îÄ model/                         # ‚Üí Entidades do dom√≠nio (regras e estado)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Usuario.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Email.java
‚îÇ   ‚îú‚îÄ‚îÄ exception/                     # ‚Üí Exce√ß√µes do dom√≠nio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DomainException.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UsuarioNotFoundException.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ EmailJaExisteException.java
‚îÇ   ‚îî‚îÄ‚îÄ service/                       # ‚Üí Regras de neg√≥cio do dom√≠nio
‚îÇ       ‚îî‚îÄ‚îÄ UsuarioDomainService.java
‚îÇ
‚îú‚îÄ‚îÄ application/                       # üí° Camada de Aplica√ß√£o (Casos de Uso)
‚îÇ   ‚îú‚îÄ‚îÄ port/                          # ‚Üí Portas (interfaces para entrada/sa√≠da)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/                     # ‚Ü™ Input Ports (Interfaces de casos de uso)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CriarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BuscarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AtualizarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InativarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/                    # ‚Ü™ Output Ports (interfaces para depend√™ncias)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioRepositoryPort.java
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ EmailServicePort.java
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PasswordEncoderPort.java
‚îÇ   ‚îú‚îÄ‚îÄ service/                       # ‚Üí Implementa√ß√µes dos casos de uso
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CriarUsuarioService.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BuscarUsuarioService.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AtualizarUsuarioService.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InativarUsuarioService.java
‚îÇ   ‚îî‚îÄ‚îÄ dto/                           # ‚Üí Objetos de transfer√™ncia de dados
‚îÇ       ‚îú‚îÄ‚îÄ UsuarioDTO.java
‚îÇ       ‚îú‚îÄ‚îÄ CreateUsuarioCommand.java
‚îÇ       ‚îî‚îÄ‚îÄ UpdateUsuarioCommand.java
‚îÇ
‚îú‚îÄ‚îÄ infrastructure/                   # üõ†Ô∏è Infraestrutura (Adapters + Configura√ß√µes)
‚îÇ   ‚îú‚îÄ‚îÄ adapter/                      # ‚Üí Adaptadores concretos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/                    # ‚Ü™ Adaptadores Prim√°rios (ex: Web)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ web/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioController.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ GlobalExceptionHandler.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/                   # ‚Ü™ Adaptadores Secund√°rios (Banco, Email...)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ persistence/
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ UsuarioJpaRepository.java
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ UsuarioRepositoryAdapter.java
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ entity/
‚îÇ   ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntity.java
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ encoder/
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ BCryptPasswordEncoderAdapter.java
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ email/
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ EmailServiceAdapter.java
‚îÇ   ‚îú‚îÄ‚îÄ config/                       # ‚Üí Configura√ß√µes (Beans, JPA, etc)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BeanConfiguration.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DatabaseConfig.java
‚îÇ   ‚îî‚îÄ‚îÄ mapper/                       # ‚Üí Conversores (domain <-> entity/dto)
‚îÇ       ‚îú‚îÄ‚îÄ UsuarioMapper.java
‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntityMapper.java

```

-   **Estrutura cl√°ssica da Arquitetura Hexagonal em camadas globais**, n√£o modularizada por features:

    -   `domain/` ‚Äî n√∫cleo do dom√≠nio com entidades, exce√ß√µes, servi√ßos de dom√≠nio
    -   `application/` ‚Äî casos de uso, portas, DTOs, servi√ßos de aplica√ß√£o
    -   `infrastructure/` ‚Äî adaptadores e configura√ß√µes gerais da infraestrutura

-   **Todas as entidades e servi√ßos do dom√≠nio ficam numa pasta √∫nica `domain/`**
-   **Todos os casos de uso e servi√ßos de aplica√ß√£o tamb√©m ficam em `application/`**
-   **Adaptadores de entrada e sa√≠da est√£o organizados dentro da pasta `infrastructure/`**
-   **Separa√ß√£o mais tradicional e ampla, menos modular**

**Resumo:** Organiza√ß√£o em camadas horizontais globais, onde cada camada √© √∫nica e engloba toda a aplica√ß√£o.

### Principais diferen√ßas resumidas

| Aspecto              | Estrutura B√°sica Modular                             | Estrutura Completa em Camadas Globais                        |
| -------------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| Organiza√ß√£o          | Por m√≥dulos (ex: m√≥dulo user)                        | Por camadas (domain, application, infrastructure)            |
| Isolamento           | Cada m√≥dulo tem dom√≠nio, aplica√ß√£o e infra separadas | Dom√≠nio, aplica√ß√£o e infra s√£o globais para toda a aplica√ß√£o |
| Reuso entre m√≥dulos  | Usa `shared/` para componentes comuns                | C√≥digo comum fica em camadas (ex: config, mappers) globais   |
| Escalabilidade       | Facilita crescimento com v√°rios m√≥dulos              | Pode ficar mais dif√≠cil escalar com muitos recursos          |
| Complexidade inicial | Pode ser mais complexa inicialmente                  | Estrutura mais simples para projetos pequenos                |
| Manuten√ß√£o           | Boa para times grandes e m√∫ltiplos dom√≠nios          | Melhor para projetos pequenos ou m√©dios                      |

---

### Quando usar cada uma?

-   **Modular** ‚Äî Projetos maiores, com muitos dom√≠nios/m√≥dulos, times trabalhando separadamente.
-   **Estrutura Separa√ß√£o por Camadas Globais** ‚Äî Projetos menores, prot√≥tipos, quando a equipe √© pequena e o dom√≠nio n√£o precisa ser muito fragmentado.

### 2.2 Compara√ß√£o: 3 Camadas vs Hexagonal

| Aspecto           | 3 Camadas                         | Hexagonal                            |
| ----------------- | --------------------------------- | ------------------------------------ |
| **Acoplamento**   | Controller ‚Üí Service ‚Üí Repository | Ports ‚Üî Adapters                     |
| **Depend√™ncias**  | Camadas dependem de frameworks    | Core independe de tudo               |
| **Testabilidade** | Mocks complexos                   | Mocks simples (interfaces)           |
| **Flexibilidade** | Mudan√ßas afetam m√∫ltiplas camadas | Mudan√ßas isoladas em adapters        |
| **Complexidade**  | Menor (inicial)                   | Maior (inicial), menor (longo prazo) |

---

# Implementa√ß√£o

Em contru√ß√£o

# Pr√≥ximos passos:

## Parte 3: Modularizar e criar novos m√≥dulos

### Nova Estrutura

√ìtima pergunta! Se voc√™ for **modularizar** a aplica√ß√£o (ex: separando os dom√≠nios `user` e `account`), o ideal √© **isolar a responsabilidade de cada m√≥dulo**, mantendo **a Arquitetura Hexagonal** em cada um, como se cada dom√≠nio fosse uma mini-aplica√ß√£o dentro do projeto.

---

### ‚úÖ Estrutura com M√≥dulos: `user` e `account`

```text
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java
‚îú‚îÄ‚îÄ user/                              # üßç M√≥dulo de Usu√°rio
‚îÇ   ‚îú‚îÄ‚îÄ domain/                        # ‚Üê CORE do m√≥dulo usu√°rio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/ (Usuario.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/ (CriarUsuarioUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/ (UsuarioRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/ (CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/ (UsuarioController.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioRepositoryAdapter.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntity.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ encoder/, email/
‚îÇ   ‚îî‚îÄ‚îÄ mapper/ (UsuarioMapper.java)
‚îÇ
‚îú‚îÄ‚îÄ account/                           # üè¶ M√≥dulo de Conta Banc√°ria
‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/ (Conta.java, Transacao.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/ (AbrirContaUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/ (ContaRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/ (AbrirContaService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/ (ContaController.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ContaRepositoryAdapter.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ContaEntity.java
‚îÇ   ‚îî‚îÄ‚îÄ mapper/ (ContaMapper.java)
‚îÇ
‚îú‚îÄ‚îÄ shared/                            # üì¶ C√≥digo compartilhado (se necess√°rio)
‚îÇ   ‚îú‚îÄ‚îÄ config/ (DatabaseConfig.java, BeanConfig.java)
‚îÇ   ‚îú‚îÄ‚îÄ exception/ (GlobalExceptionHandler.java)
‚îÇ   ‚îî‚îÄ‚îÄ util/
```

A estrutura modularizada por funcionalidade (como user/, account/) √© mais did√°tica, mais clara para aprender, escalar e manter, especialmente quando voc√™ est√° explicando para alunos ou iniciando em projetos maiores.

---

### üí° Benef√≠cios dessa modulariza√ß√£o:

| Vantagem                           | Explica√ß√£o                                              |
| ---------------------------------- | ------------------------------------------------------- |
| **Separa√ß√£o de responsabilidades** | `user` cuida de usu√°rios, `account` cuida de contas     |
| **Reutiliza√ß√£o**                   | Voc√™ pode mover um m√≥dulo para outro projeto, se quiser |
| **Facilidade de testes**           | Cada m√≥dulo pode ser testado isoladamente               |
| **Escalabilidade**                 | Pode evoluir cada m√≥dulo de forma independente          |

---

Se quiser, posso gerar **um diagrama visual ou PlantUML** com essa estrutura modular. Deseja isso tamb√©m?

```

```
