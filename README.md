# Tutorial 2: Refatora√ß√£o para Arquitetura Hexagonal

## Java Spring Boot + SQLite + Clean Architecture

### Sum√°rio Executivo

Este tutorial refatora o sistema CRUD de usu√°rios da **arquitetura em 3 camadas** para **Arquitetura Hexagonal** (tamb√©m conhecida como **Ports and Adapters** ou **Clean Architecture**), aplicando conceitos avan√ßados de **Domain-Driven Design (DDD)** e **princ√≠pios de Clean Code**.

Acesso ao c√≥digo em 3 camadas para iniciar o tutorial:
[Acesse o reposit√≥rio no GitHub](https://github.com/leonardorsolar/user-hexagonal-java-1-2-crud)

---

## Parte 1: Fundamentos da Arquitetura Hexagonal

### 1.1 O que √© Arquitetura Hexagonal?

A **Arquitetura Hexagonal** foi criada por **Alistair Cockburn**.
A Arquitetura Hexagonal, tamb√©m chamada de Ports and Adapters, √© um modelo de organiza√ß√£o de software que separa a l√≥gica de neg√≥cio (o n√∫cleo da aplica√ß√£o) das partes externas, como banco de dados, APIs e interface web.

Vamos visualizar forma de vermos a Arquitetura para entendermos melhor como aplic√°-la.

![Arquitetura Hexagonal](./docs/image/arquiteturahexagonal.png)

-   A regra de neg√≥cio fica no centro (n√∫cleo).

-   As interfaces externas (como controller, banco de dados, e-mail) se conectam ao n√∫cleo por meio de portas (interfaces) e adaptadores (implementa√ß√µes).

-   Isso facilita testes, manuten√ß√£o e troca de tecnologias.

üß† Exemplo simples:
Voc√™ pode trocar o banco de dados sem mudar a l√≥gica da aplica√ß√£o.

Pode testar tudo sem subir o servidor.

Vamos comprender mais a base desta arquitetura.

```
+---------------------+
|   InterfaceClasse  |  <<interface>>
+---------------------+
          ^
          |
+---------------------+
|     ClasseImpl     |  implements InterfaceClasse (classe concreta)
+---------------------+
```

## O que √© **implementar uma interface**?

√â criar uma classe que **segue esse contrato**, ou seja, define o comportamento dos m√©todos que foram apenas declarados na interface.

---

### üß© Exemplo da interface:

```java
public interface UsuarioService {
    UsuarioDTO criar(CreateUsuarioDTO dto);
    UsuarioDTO atualizar(Long id, UpdateUsuarioDTO dto);
    void deletar(Long id);
}
```

Essa interface define **o que deve ser feito**, mas **n√£o diz como**.

---

### üîß Exemplo da implementa√ß√£o:

```java
public class UsuarioServiceImpl implements UsuarioService {

    @Override
    public UsuarioDTO criar(CreateUsuarioDTO dto) {
        // Aqui voc√™ coloca a l√≥gica para criar um usu√°rio
    }

    @Override
    public UsuarioDTO atualizar(Long id, UpdateUsuarioDTO dto) {
        // Aqui voc√™ coloca a l√≥gica para atualizar um usu√°rio
    }

    @Override
    public void deletar(Long id) {
        // Aqui voc√™ coloca a l√≥gica para deletar um usu√°rio
    }
}
```

---

### ‚úÖ Resumo:

-   A **interface** √© o **contrato**: define _o que precisa ser feito_.
-   A **classe que implementa a interface** fornece a **l√≥gica real**: define _como isso ser√° feito_.

```
`  +---------------------+
  |      Controller      |  <- Adapter (classe concreta)
  | (UsuarioController)  |
  +----------+----------+
             |
             v
     +-----------------+
     |   Input Port    |  <- Interface
     | (UsuarioService)|
     +-------+---------+
             ^
             |
     +--------------------+
     |     **Core**       |  <- Implementa√ß√£o da l√≥gica (classe concreta)
     |(UsuarioServiceImpl)|
     +-------+------------+
             |
             v
    +--------------------+
    |  Output Port       |  <- Interface
    | (UsuarioRepository)|
    +-------+------------+
             ^
             |
  +-------------------------+
  |      Adapter            |
  | (UsuarioRepositoryImpl) |   <- Adapter (classe concreta)
  |     Database            |
  +--------------------------+`

```

### Observe aqui que o centro UsuarioServiceImpl (Core da aplica√ß√£o) aponta (usa) a classe de cima (UsuarioService) e aponta (usa) a classe de baixo (UsuarioRepository) e as classe que a core usa s√£o interfaces (contratos) e n√£o classe concretas.

---

-   **Controller (Adapter):** recebe requisi√ß√µes e chama o InputPort.
-   **InputPort (Interface):** define os m√©todos que o Controller usa.
-   **Core (Implementa√ß√£o):** a l√≥gica do servi√ßo implementa InputPort.
-   **OutputPort (Interface):** abstrai o acesso a dados.
-   **Adapter (Database):** implementa OutputPort para persist√™ncia real.

### üîÅ Diagrama **sem interfaces (acoplado)** para comparar:

```text
  +---------------------+
  |     Controller      |
  | (UsuarioController) | (classe concreta)
  +----------+----------+
             |
             v
     +--------------------+
     |     Service        |
     |(UsuarioServiceImpl)|  (classe concreta)
     +--------+-----------+
              |
              v
     +--------------------------+
     |     Repository Impl      |  (classe concreta)
     | (UsuarioRepositoryImpl)  |
     +--------------------------+
```

### üß® Problema aqui:

-   O `Controller` chama diretamente a implementa√ß√£o (`ServiceImpl`), que por sua vez chama diretamente o `RepositoryImpl`.
-   Isso **viola o DIP (Princ√≠pio da Invers√£o de Depend√™ncia)**.
-   Torna o sistema mais r√≠gido e dif√≠cil de testar.

---

### ‚úÖ J√° o primeiro diagrama:

-   Usa **interfaces entre as camadas**, garantindo **desacoplamento**.
-   Permite trocar implementa√ß√µes facilmente.
-   Favorece testes com _mocks_ e simula√ß√µes.

### Outra forma de visualizar o diagrama:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     WORLD OUTSIDE                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ   Web API    ‚îÇ  ‚îÇ   Database   ‚îÇ  ‚îÇ  External    ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  (Adapter)   ‚îÇ  ‚îÇ  (Adapter)   ‚îÇ  ‚îÇ   Services   ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ         ‚îÇ                 ‚îÇ                 ‚îÇ             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ Input Port   ‚îÇ  ‚îÇOutput Port   ‚îÇ  ‚îÇOutput Port   ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ(Interface)   ‚îÇ  ‚îÇ(Interface)   ‚îÇ  ‚îÇ(Interface)   ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ         ‚îÇ                 ‚îÇ                 ‚îÇ             ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ
‚îÇ                           ‚îÇ                               ‚îÇ
‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ    ‚îÇ           HEXAGON (CORE)                  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ                                           ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ         APPLICATION LAYER           ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ     (Use Cases / Services)          ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ                                     ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îÇ       DOMAIN LAYER          ‚îÇ    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îÇ   (Entities / Business)     ‚îÇ    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îÇ                             ‚îÇ    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ          ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Outra base para entender a arquitetura Hexagonal √© o conceito de Invers√£o de Depend√™ncia (ou Invers√£o de Controle)

## üß± Fundamento da Arquitetura Hexagonal: **Invers√£o de Depend√™ncia (DIP)**

Antes de entender a arquitetura Hexagonal, √© importante conhecer um conceito essencial chamado **Invers√£o de Depend√™ncia**, que tamb√©m √© conhecido como **Invers√£o de Controle**.

---

## üö¶ O que √© o DIP (Princ√≠pio da Invers√£o de Depend√™ncia)?

> O DIP diz que **as partes mais importantes do sistema (alto n√≠vel)** n√£o devem depender diretamente dos **detalhes t√©cnicos (baixo n√≠vel)**.
> Em vez disso, **ambos devem depender de uma interface (abstra√ß√£o)** que define o que precisa ser feito, mas n√£o como.

---

### üß† De forma simples:

-   **Alto n√≠vel** ‚Üí define **o que** o sistema deve fazer.
    Exemplo: a classe `UsuarioService`, onde est√° a l√≥gica de neg√≥cio.

-   **Baixo n√≠vel** ‚Üí cuida de **como** as coisas acontecem.
    Exemplo: `UsuarioRepository`, que salva os dados no banco.

---

## ü§ù Como eles se comunicam?

‚û°Ô∏è Atrav√©s de **interfaces** (ou contratos).
Assim, o c√≥digo principal do sistema **n√£o precisa conhecer os detalhes t√©cnicos**.

---

Vejamos mais um diagrama:

```
        +------------------------+
        |  UsuarioService        |  <- C√≥digo de alto n√≠vel
        |------------------------|
        | - usuarioRepository    |   <- Inje√ß√£o de depend√™ncia na classe UsuarioService
        +-----------+------------+
                    |
                    v
        +------------------------+
        |  UsuarioRepository     |  <- Interface (abstra√ß√£o - contrato)
        +-----------+------------+
                    ^
                    |
        +------------------------+
        | UsuarioRepositoryImpl  |  <- C√≥digo de baixo n√≠vel (implementa√ß√£o da interface)
        +------------------------+
```

Interpreta√ß√£o:

-   UsuarioService (n√≠vel alto) depende da interface UsuarioRepository, e n√£o sabe nem se importa com quem a implementa.
-   UsuarioRepositoryImpl (n√≠vel baixo) √© quem realmente implementa o contrato da interface e executa a a√ß√£o real de salvar.
-   Isso √© a ess√™ncia do DIP: alto e baixo n√≠vel n√£o se conhecem diretamente, e tudo depende de interfaces.

## ‚úÖ Exemplo pr√°tico no seu projeto:

```java
// Interface: contrato entre alto e baixo n√≠vel
public interface UsuarioRepository {
    void salvar(Usuario usuario);
}

// Baixo n√≠vel implementa esse contrato
public class UsuarioRepositoryImpl implements UsuarioRepository {
    public void salvar(Usuario usuario) {
        // l√≥gica que salva no banco de dados
    }
}

// Alto n√≠vel (servi√ßo) usa a interface, n√£o a implementa√ß√£o concreta
public class UsuarioService {
    private final UsuarioRepository usuarioRepository;

    public UsuarioService(UsuarioRepository usuarioRepository) {
        this.usuarioRepository = usuarioRepository;
    }

    public void registrarUsuario(Usuario usuario) {
        usuarioRepository.salvar(usuario); // n√£o importa como, apenas que funciona
    }
}
```

---

## üîå Analogia simples:

Imagine isso:

-   O celular √© o **controller** e precisa ser carregado.
-   O carregado **precisa de um carregador com entrada USB-C** (interface).
-   Qualquer carregador que tenha essa entrada serve, n√£o importa se √© da Samsung, Motorola, etc.
-   Algu√©m te entrega um carregador de qualquer marca (Samsung, Motorola...), desde que seja USB-C (implementa√ß√£o da interface).
-   O carregador real (implementa√ß√£o) √© o que executa a a√ß√£o: entregar energia
-   Voc√™ **n√£o precisa saber os detalhes**, s√≥ precisa saber que ele encaixa e funciona.

```
            +---------------------+
            |      Celular        |   <- Controller (quem solicita)
            |(Usu√°rio do sistema) |
            +---------+-----------+
                        |
                        v
            +--------------------+
            |     Entrada USB-C   |   <- Interface (abstra√ß√£o)
            | (Contrato esperado) |
            +---------+----------+
                        ^
            ____________|______________________
            |               |                |
            v               v                v
    +-----------+    +-----------+    +-------------+
    | Carregador|    | Carregador|    | Carregador  |
    | Samsung   |    | Motorola  |    | Gen√©rico    |
    +-----------+    +-----------+    +-------------+
(Impl. concreta)    (Impl. concreta)  (Impl. concreta)
```

### üß† Tradu√ß√£o para o c√≥digo:

| Analogia           | C√≥digo Spring Boot                    |
| ------------------ | ------------------------------------- |
| Celular            | `Controller`                          |
| Entrada USB-C      | `UsuarioService` (interface)          |
| Carregador Samsung | `UsuarioServiceImpl` (implementa√ß√£o)  |
| Energia fluindo    | `registrarUsuario()` (a√ß√£o executada) |

---

![Arquitetura Hexagonal](./docs/image/ports_and_adapters.png)

### 1.2 Conceitos Fundamentais

#### **Ports (Portas)**

-   **Input Ports**: Interfaces que definem casos de uso
-   **Output Ports**: Interfaces que definem depend√™ncias externas

#### **Adapters (Adaptadores)**

-   **Primary Adapters**: Iniciam a√ß√µes (Controllers, CLI, etc.)
-   **Secondary Adapters**: Implementam funcionalidades (Database, APIs, etc.)

#### **Core (N√∫cleo)**

-   **Domain Layer**: Entidades e regras de neg√≥cio
-   **Application Layer**: Casos de uso e orquestra√ß√£o

### 1.3 Vantagens da Arquitetura Hexagonal

#### ‚úÖ **Desacoplamento Total**

-   Dom√≠nio independente de frameworks
-   F√°cil troca de tecnologias (database, web framework, etc.)

#### ‚úÖ **Testabilidade M√°xima**

-   Core pode ser testado sem infraestrutura
-   Mocks simples para adapters

#### ‚úÖ **Flexibilidade**

-   M√∫ltiplos adapters (REST API, GraphQL, CLI)
-   Diferentes bancos de dados (SQLite, PostgreSQL, MongoDB)

#### ‚úÖ **Manutenibilidade**

-   Regras de neg√≥cio centralizadas
-   Mudan√ßas de infraestrutura n√£o afetam o core

---

![Arquitetura Hexagonal](./docs/image/modelo.png)

## Parte 2: Estrutura da Arquitetura Hexagonal

### 2.1 Nova Estrutura do Projeto

```bash
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java          # Classe principal (Spring Boot)

‚îú‚îÄ‚îÄ domain/                            # üí† N√∫cleo (Dom√≠nio - Core do Hex√°gono)
‚îÇ   ‚îú‚îÄ‚îÄ model/                         # ‚Üí Entidades do dom√≠nio (regras e estado)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Usuario.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Email.java
‚îÇ   ‚îú‚îÄ‚îÄ exception/                     # ‚Üí Exce√ß√µes do dom√≠nio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DomainException.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UsuarioNotFoundException.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ EmailJaExisteException.java
‚îÇ   ‚îî‚îÄ‚îÄ service/                       # ‚Üí Regras de neg√≥cio do dom√≠nio
‚îÇ       ‚îî‚îÄ‚îÄ UsuarioDomainService.java

‚îú‚îÄ‚îÄ application/                       # üí° Camada de Aplica√ß√£o (Casos de Uso)
‚îÇ   ‚îú‚îÄ‚îÄ port/                          # ‚Üí Portas (interfaces para entrada/sa√≠da)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/                     # ‚Ü™ Input Ports (Interfaces de casos de uso)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CriarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BuscarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AtualizarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InativarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/                    # ‚Ü™ Output Ports (interfaces para depend√™ncias)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioRepositoryPort.java
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ EmailServicePort.java
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PasswordEncoderPort.java
‚îÇ   ‚îú‚îÄ‚îÄ service/                       # ‚Üí Implementa√ß√µes dos casos de uso
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CriarUsuarioService.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BuscarUsuarioService.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AtualizarUsuarioService.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InativarUsuarioService.java
‚îÇ   ‚îî‚îÄ‚îÄ dto/                           # ‚Üí Objetos de transfer√™ncia de dados
‚îÇ       ‚îú‚îÄ‚îÄ UsuarioDTO.java
‚îÇ       ‚îú‚îÄ‚îÄ CreateUsuarioCommand.java
‚îÇ       ‚îî‚îÄ‚îÄ UpdateUsuarioCommand.java

‚îú‚îÄ‚îÄ infrastructure/                   # üõ†Ô∏è Infraestrutura (Adapters + Configura√ß√µes)
‚îÇ   ‚îú‚îÄ‚îÄ adapter/                      # ‚Üí Adaptadores concretos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/                    # ‚Ü™ Adaptadores Prim√°rios (ex: Web)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ web/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioController.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ GlobalExceptionHandler.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/                   # ‚Ü™ Adaptadores Secund√°rios (Banco, Email...)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ persistence/
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ UsuarioJpaRepository.java
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ UsuarioRepositoryAdapter.java
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ entity/
‚îÇ   ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntity.java
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ encoder/
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ BCryptPasswordEncoderAdapter.java
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ email/
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ EmailServiceAdapter.java
‚îÇ   ‚îú‚îÄ‚îÄ config/                       # ‚Üí Configura√ß√µes (Beans, JPA, etc)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BeanConfiguration.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DatabaseConfig.java
‚îÇ   ‚îî‚îÄ‚îÄ mapper/                       # ‚Üí Conversores (domain <-> entity/dto)
‚îÇ       ‚îú‚îÄ‚îÄ UsuarioMapper.java
‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntityMapper.java

```

Deste que utizemos a invers√£o de depend√™ncia podemos estruturar as pastas da nossa maneira.

-   Core (Dom√≠nio): √© o cora√ß√£o da aplica√ß√£o. N√£o conhece o banco, nem o Spring. Cont√©m a l√≥gica pura.
-   Application Layer: orquestra os casos de uso. Usa interfaces (ports) para se comunicar com o mundo externo.
-   Infrastructure: √© o mundo externo ‚Äî onde ficam os detalhes concretos (Web, Banco de Dados, Email...).
-   Adapters: ligam o mundo externo (Infra) ao core, implementando as interfaces da camada de aplica√ß√£o.

### 2.2 Compara√ß√£o: 3 Camadas vs Hexagonal

| Aspecto           | 3 Camadas                         | Hexagonal                            |
| ----------------- | --------------------------------- | ------------------------------------ |
| **Acoplamento**   | Controller ‚Üí Service ‚Üí Repository | Ports ‚Üî Adapters                     |
| **Depend√™ncias**  | Camadas dependem de frameworks    | Core independe de tudo               |
| **Testabilidade** | Mocks complexos                   | Mocks simples (interfaces)           |
| **Flexibilidade** | Mudan√ßas afetam m√∫ltiplas camadas | Mudan√ßas isoladas em adapters        |
| **Complexidade**  | Menor (inicial)                   | Maior (inicial), menor (longo prazo) |

---

# Implementa√ß√£o

Em contru√ß√£o

# Pr√≥ximos passos:

## Parte 3: Modularizar e criar novos m√≥dulos

### Nova Estrutura

√ìtima pergunta! Se voc√™ for **modularizar** a aplica√ß√£o (ex: separando os dom√≠nios `user` e `account`), o ideal √© **isolar a responsabilidade de cada m√≥dulo**, mantendo **a Arquitetura Hexagonal** em cada um, como se cada dom√≠nio fosse uma mini-aplica√ß√£o dentro do projeto.

---

### ‚úÖ Estrutura com M√≥dulos: `user` e `account`

```text
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java
‚îú‚îÄ‚îÄ user/                              # üßç M√≥dulo de Usu√°rio
‚îÇ   ‚îú‚îÄ‚îÄ domain/                        # ‚Üê CORE do m√≥dulo usu√°rio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/ (Usuario.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/ (CriarUsuarioUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/ (UsuarioRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/ (CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/ (UsuarioController.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioRepositoryAdapter.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntity.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ encoder/, email/
‚îÇ   ‚îî‚îÄ‚îÄ mapper/ (UsuarioMapper.java)
‚îÇ
‚îú‚îÄ‚îÄ account/                           # üè¶ M√≥dulo de Conta Banc√°ria
‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/ (Conta.java, Transacao.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/ (AbrirContaUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/ (ContaRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/ (AbrirContaService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/ (ContaController.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ContaRepositoryAdapter.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ContaEntity.java
‚îÇ   ‚îî‚îÄ‚îÄ mapper/ (ContaMapper.java)
‚îÇ
‚îú‚îÄ‚îÄ shared/                            # üì¶ C√≥digo compartilhado (se necess√°rio)
‚îÇ   ‚îú‚îÄ‚îÄ config/ (DatabaseConfig.java, BeanConfig.java)
‚îÇ   ‚îú‚îÄ‚îÄ exception/ (GlobalExceptionHandler.java)
‚îÇ   ‚îî‚îÄ‚îÄ util/
```

---

### üí° Benef√≠cios dessa modulariza√ß√£o:

| Vantagem                           | Explica√ß√£o                                              |
| ---------------------------------- | ------------------------------------------------------- |
| **Separa√ß√£o de responsabilidades** | `user` cuida de usu√°rios, `account` cuida de contas     |
| **Reutiliza√ß√£o**                   | Voc√™ pode mover um m√≥dulo para outro projeto, se quiser |
| **Facilidade de testes**           | Cada m√≥dulo pode ser testado isoladamente               |
| **Escalabilidade**                 | Pode evoluir cada m√≥dulo de forma independente          |

---

Se quiser, posso gerar **um diagrama visual ou PlantUML** com essa estrutura modular. Deseja isso tamb√©m?

```

```
