# Tutorial 3: Refatora√ß√£o para Arquitetura Hexagonal

## Java Spring Boot + SQLite + Clean Architecture

### Sum√°rio Executivo

Este tutorial refatora o sistema CRUD de usu√°rios da **arquitetura em 3 camadas** para **Arquitetura Hexagonal** (tamb√©m conhecida como **Ports and Adapters** ou **Clean Architecture**), aplicando conceitos avan√ßados de **Domain-Driven Design (DDD)** e **princ√≠pios de Clean Code**.

Acesso ao c√≥digo em 3 camadas para iniciar o tutorial:
[Acesse o reposit√≥rio no GitHub](https://github.com/leonardorsolar/user-hexagonal-java-1-2-crud)

---

## Parte 1: Fundamentos da Arquitetura Hexagonal

### 1.1 O que √© Arquitetura Hexagonal?

A **Arquitetura Hexagonal** foi criada por **Alistair Cockburn**.
A Arquitetura Hexagonal, tamb√©m chamada de Ports and Adapters, √© um modelo de organiza√ß√£o de software que separa a l√≥gica de neg√≥cio (o n√∫cleo da aplica√ß√£o) das partes externas, como banco de dados, APIs e interface web.

Vamos visualizar forma de vermos a Arquitetura para entendermos melhor como aplic√°-la.

![Arquitetura Hexagonal](./docs/image/arquiteturahexagonal.png)

-   A regra de neg√≥cio fica no centro (n√∫cleo).

-   As interfaces externas (como controller, banco de dados, e-mail) se conectam ao n√∫cleo por meio de portas (interfaces) e adaptadores (implementa√ß√µes).

-   Isso facilita testes, manuten√ß√£o e troca de tecnologias.

üß† Exemplo simples:
Voc√™ pode trocar o banco de dados sem mudar a l√≥gica da aplica√ß√£o.

Pode testar tudo sem subir o servidor.

Vamos comprender mais a base desta arquitetura.

```
+---------------------+
|   InterfaceClasse  |  <<interface>>
+---------------------+
          ^
          |
+---------------------+
|     ClasseImpl     |  implements InterfaceClasse (classe concreta)
+---------------------+
```

## O que √© **implementar uma interface**?

√â criar uma classe que **segue esse contrato**, ou seja, define o comportamento dos m√©todos que foram apenas declarados na interface.

---

### üß© Exemplo da interface:

```java
public interface UsuarioService {
    UsuarioDTO criar(CreateUsuarioDTO dto);
    UsuarioDTO atualizar(Long id, UpdateUsuarioDTO dto);
    void deletar(Long id);
}
```

Essa interface define **o que deve ser feito**, mas **n√£o diz como**.

---

### üîß Exemplo da implementa√ß√£o:

```java
public class UsuarioServiceImpl implements UsuarioService {

    @Override
    public UsuarioDTO criar(CreateUsuarioDTO dto) {
        // Aqui voc√™ coloca a l√≥gica para criar um usu√°rio
    }

    @Override
    public UsuarioDTO atualizar(Long id, UpdateUsuarioDTO dto) {
        // Aqui voc√™ coloca a l√≥gica para atualizar um usu√°rio
    }

    @Override
    public void deletar(Long id) {
        // Aqui voc√™ coloca a l√≥gica para deletar um usu√°rio
    }
}
```

---

### ‚úÖ Resumo:

-   A **interface** √© o **contrato**: define _o que precisa ser feito_.
-   A **classe que implementa a interface** fornece a **l√≥gica real**: define _como isso ser√° feito_.

```
`  +---------------------+
  |      Controller      |  <- Adapter (classe concreta)
  | (UsuarioController)  |
  +----------+----------+
             |
             v
     +-----------------+
     |   Input Port    |  <- Interface
     | (UsuarioService)|
     +-------+---------+
             ^
             |
     +--------------------+
     |     **Core**       |  <- Implementa√ß√£o da l√≥gica (classe concreta)
     |(UsuarioServiceImpl)|
     +-------+------------+
             |
             v
    +--------------------+
    |  Output Port       |  <- Interface
    | (UsuarioRepository)|
    +-------+------------+
             ^
             |
  +-------------------------+
  |      Adapter            |
  | (UsuarioRepositoryImpl) |   <- Adapter (classe concreta)
  |     Database            |
  +--------------------------+`

```

### Observe aqui que o centro UsuarioServiceImpl (Core da aplica√ß√£o) aponta (usa) a classe de cima (UsuarioService) e aponta (usa) a classe de baixo (UsuarioRepository) e as classe que a core usa s√£o interfaces (contratos) e n√£o classe concretas.

---

-   **Controller (Adapter):** recebe requisi√ß√µes e chama o InputPort.
-   **InputPort (Interface):** define os m√©todos que o Controller usa.
-   **Core (Implementa√ß√£o):** a l√≥gica do servi√ßo implementa InputPort.
-   **OutputPort (Interface):** abstrai o acesso a dados.
-   **Adapter (Database):** implementa OutputPort para persist√™ncia real.

### üîÅ Diagrama **sem interfaces (acoplado)** para comparar:

```text
  +---------------------+
  |     Controller      |
  | (UsuarioController) | (classe concreta)
  +----------+----------+
             |
             v
     +--------------------+
     |     Service        |
     |(UsuarioServiceImpl)|  (classe concreta)
     +--------+-----------+
              |
              v
     +--------------------------+
     |     Repository Impl      |  (classe concreta)
     | (UsuarioRepositoryImpl)  |
     +--------------------------+
```

### üß® Problema aqui:

-   O `Controller` chama diretamente a implementa√ß√£o (`ServiceImpl`), que por sua vez chama diretamente o `RepositoryImpl`.
-   Isso **viola o DIP (Princ√≠pio da Invers√£o de Depend√™ncia)**.
-   Torna o sistema mais r√≠gido e dif√≠cil de testar.

---

### ‚úÖ J√° o primeiro diagrama:

-   Usa **interfaces entre as camadas**, garantindo **desacoplamento**.
-   Permite trocar implementa√ß√µes facilmente.
-   Favorece testes com _mocks_ e simula√ß√µes.

### Outra forma de visualizar o diagrama:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     WORLD OUTSIDE                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ   Web API    ‚îÇ  ‚îÇ   Database   ‚îÇ  ‚îÇ  External    ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  (Adapter)   ‚îÇ  ‚îÇ  (Adapter)   ‚îÇ  ‚îÇ   Services   ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ         ‚îÇ                 ‚îÇ                 ‚îÇ             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ Input Port   ‚îÇ  ‚îÇOutput Port   ‚îÇ  ‚îÇOutput Port   ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ(Interface)   ‚îÇ  ‚îÇ(Interface)   ‚îÇ  ‚îÇ(Interface)   ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ         ‚îÇ                 ‚îÇ                 ‚îÇ             ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ
‚îÇ                           ‚îÇ                               ‚îÇ
‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ    ‚îÇ           HEXAGON (CORE)                  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ                                           ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ         APPLICATION LAYER           ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ     (Use Cases / Services)          ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ                                     ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îÇ       DOMAIN LAYER          ‚îÇ    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îÇ   (Entities / Business)     ‚îÇ    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îÇ                             ‚îÇ    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  ‚îÇ          ‚îÇ
‚îÇ    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ          ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Outra base para entender a arquitetura Hexagonal √© o conceito de Invers√£o de Depend√™ncia (ou Invers√£o de Controle)

## üß± Fundamento da Arquitetura Hexagonal: **Invers√£o de Depend√™ncia (DIP)**

Antes de entender a arquitetura Hexagonal, √© importante conhecer um conceito essencial chamado **Invers√£o de Depend√™ncia**, que tamb√©m √© conhecido como **Invers√£o de Controle**.

---

## üö¶ O que √© o DIP (Princ√≠pio da Invers√£o de Depend√™ncia)?

> O DIP diz que **as partes mais importantes do sistema (alto n√≠vel)** n√£o devem depender diretamente dos **detalhes t√©cnicos (baixo n√≠vel)**.
> Em vez disso, **ambos devem depender de uma interface (abstra√ß√£o)** que define o que precisa ser feito, mas n√£o como.

---

### üß† De forma simples:

-   **Alto n√≠vel** ‚Üí define **o que** o sistema deve fazer.
    Exemplo: a classe `UsuarioService`, onde est√° a l√≥gica de neg√≥cio.

-   **Baixo n√≠vel** ‚Üí cuida de **como** as coisas acontecem.
    Exemplo: `UsuarioRepository`, que salva os dados no banco.

---

## ü§ù Como eles se comunicam?

‚û°Ô∏è Atrav√©s de **interfaces** (ou contratos).
Assim, o c√≥digo principal do sistema **n√£o precisa conhecer os detalhes t√©cnicos**.

---

Vejamos mais um diagrama:

```
        +------------------------+
        |  UsuarioService        |  <- C√≥digo de alto n√≠vel
        |------------------------|
        | - usuarioRepository    |   <- Inje√ß√£o de depend√™ncia na classe UsuarioService
        +-----------+------------+
                    |
                    v
        +------------------------+
        |  UsuarioRepository     |  <- Interface (abstra√ß√£o - contrato)
        +-----------+------------+
                    ^
                    |
        +------------------------+
        | UsuarioRepositoryImpl  |  <- C√≥digo de baixo n√≠vel (implementa√ß√£o da interface)
        +------------------------+
```

Interpreta√ß√£o:

-   UsuarioService (n√≠vel alto) depende da interface UsuarioRepository, e n√£o sabe nem se importa com quem a implementa.
-   UsuarioRepositoryImpl (n√≠vel baixo) √© quem realmente implementa o contrato da interface e executa a a√ß√£o real de salvar.
-   Isso √© a ess√™ncia do DIP: alto e baixo n√≠vel n√£o se conhecem diretamente, e tudo depende de interfaces.

## ‚úÖ Exemplo pr√°tico no seu projeto:

```java
// Interface: contrato entre alto e baixo n√≠vel
public interface UsuarioRepository {
    void salvar(Usuario usuario);
}

// Baixo n√≠vel implementa esse contrato
public class UsuarioRepositoryImpl implements UsuarioRepository {
    public void salvar(Usuario usuario) {
        // l√≥gica que salva no banco de dados
    }
}

// Alto n√≠vel (servi√ßo) usa a interface, n√£o a implementa√ß√£o concreta
public class UsuarioService {
    private final UsuarioRepository usuarioRepository;

    public UsuarioService(UsuarioRepository usuarioRepository) {
        this.usuarioRepository = usuarioRepository;
    }

    public void registrarUsuario(Usuario usuario) {
        usuarioRepository.salvar(usuario); // n√£o importa como, apenas que funciona
    }
}
```

---

## üîå Analogia simples:

Imagine isso:

-   O celular √© o **controller** e precisa ser carregado.
-   O carregado **precisa de um carregador com entrada USB-C** (interface).
-   Qualquer carregador que tenha essa entrada serve, n√£o importa se √© da Samsung, Motorola, etc.
-   Algu√©m te entrega um carregador de qualquer marca (Samsung, Motorola...), desde que seja USB-C (implementa√ß√£o da interface).
-   O carregador real (implementa√ß√£o) √© o que executa a a√ß√£o: entregar energia
-   Voc√™ **n√£o precisa saber os detalhes**, s√≥ precisa saber que ele encaixa e funciona.

```
            +---------------------+
            |      Celular        |   <- Controller (quem solicita)
            |(Usu√°rio do sistema) |
            +---------+-----------+
                        |
                        v
            +--------------------+
            |     Entrada USB-C   |   <- Interface (abstra√ß√£o)
            | (Contrato esperado) |
            +---------+----------+
                        ^
            ____________|______________________
            |               |                |
            v               v                v
    +-----------+    +-----------+    +-------------+
    | Carregador|    | Carregador|    | Carregador  |
    | Samsung   |    | Motorola  |    | Gen√©rico    |
    +-----------+    +-----------+    +-------------+
(Impl. concreta)    (Impl. concreta)  (Impl. concreta)
```

### üß† Tradu√ß√£o para o c√≥digo:

| Analogia           | C√≥digo Spring Boot                    |
| ------------------ | ------------------------------------- |
| Celular            | `Controller`                          |
| Entrada USB-C      | `UsuarioService` (interface)          |
| Carregador Samsung | `UsuarioServiceImpl` (implementa√ß√£o)  |
| Energia fluindo    | `registrarUsuario()` (a√ß√£o executada) |

---

## An√°lise do lado esquerdo e direito da arquitetura

Em Arquitetura Hexagonal, o lado do "Driver" (Ator Prim√°rio) representa aqueles que iniciam a intera√ß√£o e s√£o sempre representados no lado esquerdo. O lado "Driven" (Ator Secund√°rio) corresponde aos atores que s√£o "acionados" pela aplica√ß√£o, ou seja, s√£o aqueles que a aplica√ß√£o chama.

![Arquitetura Hexagonal](./docs/image/ports_and_adapters.png)

### üß± **Centro: A Aplica√ß√£o**

-   O hex√°gono central √© a **l√≥gica principal do sistema** ‚Äî o **core** ou **dom√≠nio**.
-   Ela **n√£o conhece detalhes externos** como banco de dados, API, ou interface gr√°fica.

---

### üëâ **Lado esquerdo: Driver Side (Atores Prim√°rios)**

-   S√£o **os que iniciam a intera√ß√£o** com o sistema.
-   Ex.: usu√°rio humano, app web/mobile, testes automatizados, sistemas externos.
-   Se conectam com a aplica√ß√£o por meio de **portas de entrada (Input Ports)**.
-   Adaptadores t√≠picos: **Controllers, CLI, testes automatizados**.

---

### üëà **Lado direito: Driven Side (Atores Secund√°rios)**

-   S√£o **os que recebem comandos** da aplica√ß√£o.
-   Ex.: banco de dados, e-mail, impressora, mensageria.
-   S√£o acessados por meio de **portas de sa√≠da (Output Ports)**.
-   Adaptadores t√≠picos: **Reposit√≥rios, gateways, implementa√ß√µes t√©cnicas**.

---

| Termo           | Papel                                                             |
| --------------- | ----------------------------------------------------------------- |
| **Application** | N√∫cleo da aplica√ß√£o, isolado das tecnologias                      |
| **Driver Side** | Quem chama a aplica√ß√£o (ex.: Controller, User)                    |
| **Driven Side** | Quem √© chamado pela aplica√ß√£o (ex.: Banco de dados, SMTP)         |
| **Input Port**  | Interface usada para entrar no n√∫cleo                             |
| **Output Port** | Interface usada pelo n√∫cleo para se comunicar com o mundo externo |

### 1.2 Conceitos Fundamentais

#### **Ports (Portas)**

-   **Input Ports**: Interfaces que definem casos de uso
-   **Output Ports**: Interfaces que definem depend√™ncias externas

#### **Adapters (Adaptadores)**

-   **Primary Adapters**: Iniciam a√ß√µes (Controllers, CLI, etc.)
-   **Secondary Adapters**: Implementam funcionalidades (Database, APIs, etc.)

#### **Core (N√∫cleo)**

-   **Domain Layer**: Entidades e regras de neg√≥cio
-   **Application Layer**: Casos de uso e orquestra√ß√£o

### 1.3 Vantagens da Arquitetura Hexagonal

#### ‚úÖ **Desacoplamento Total**

-   Dom√≠nio independente de frameworks
-   F√°cil troca de tecnologias (database, web framework, etc.)

#### ‚úÖ **Testabilidade M√°xima**

-   Core pode ser testado sem infraestrutura
-   Mocks simples para adapters

#### ‚úÖ **Flexibilidade**

-   M√∫ltiplos adapters (REST API, GraphQL, CLI)
-   Diferentes bancos de dados (SQLite, PostgreSQL, MongoDB)

#### ‚úÖ **Manutenibilidade**

-   Regras de neg√≥cio centralizadas
-   Mudan√ßas de infraestrutura n√£o afetam o core

---

![Arquitetura Hexagonal](./docs/image/modelo.png)

## Parte 2: Estrutura da Arquitetura Hexagonal

Podemos ter v√°rias forma de organizar as pastas do projeto.
A Estrutura a seguir 1 e 2 focam na ideia cl√°ssica de Hexagonal Architecture:

-   Separar adaptadores (adapters) que conectam o mundo externo (interfaces, APIs, bancos) da l√≥gica da aplica√ß√£o (application).

## üü® Estrutura 1 com `adapters` e `application`

![Arquitetura Hexagonal](./docs/image/aplicaAdp.png)

```text
src/
‚îú‚îÄ‚îÄ adapters/                             # üîå Adaptadores que conectam o mundo externo ao sistema
‚îÇ   ‚îú‚îÄ‚îÄ inbound/                          # ‚Ü©Ô∏è Entrada: recebe requisi√ß√µes externas (ex: APIs, controllers)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ controller/                   #    ‚îî‚îÄ‚îÄ Controladores REST ou HTTP que iniciam os casos de uso
‚îÇ   ‚îî‚îÄ‚îÄ outbound/                         # ‚Ü™Ô∏è Sa√≠da: comunica com sistemas externos (ex: banco de dados, servi√ßos)
‚îÇ       ‚îî‚îÄ‚îÄ repository/                   #    ‚îî‚îÄ‚îÄ Implementa√ß√µes de persist√™ncia (ex: JPA, Mongo, JDBC)

‚îú‚îÄ‚îÄ application/                          # üß† L√≥gica de aplica√ß√£o (casos de uso e orquestra√ß√£o)
‚îÇ   ‚îú‚îÄ‚îÄ core/                             #    üîÅ N√∫cleo da aplica√ß√£o (sem depend√™ncias externas)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/                       #     ‚öôÔ∏è Implementa√ß√µes dos casos de uso (ex: CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ domain/                       #       Entidades de neg√≥cio e regras do dom√≠nio
‚îÇ   ‚îî‚îÄ‚îÄ ports/                            #    üö™ Interfaces que definem os contratos da aplica√ß√£o
‚îÇ       ‚îú‚îÄ‚îÄ in/                           #       ‚Ü©Ô∏è Portas de entrada: contratos dos casos de uso
‚îÇ       ‚îî‚îÄ‚îÄ out/                          #       ‚Ü™Ô∏è Portas de sa√≠da: contratos com infraestrutura (repos, servi√ßos)
‚îú‚îÄ‚îÄ shared/
```

-   Adapters √© o termo cl√°ssico da arquitetura hexagonal para os componentes que adaptam o sistema ao ambiente externo.
-   A pasta application pode conter o que chamamos de casos de uso, servi√ßos e portas (interfaces)
-   Nomes como inbound e outbound explicam claramente o fluxo (entrada/sa√≠da).
-   core √© um termo mais gen√©rico.

Outra forma de se expressas

## üü® Estrutura 2 com `adapters` e `application`

```text
src/
‚îú‚îÄ‚îÄ adapters/                             # üîå Adaptadores que conectam o mundo externo ao sistema
‚îÇ   ‚îú‚îÄ‚îÄ in/                               # ‚Ü©Ô∏è Entrada: recebe requisi√ß√µes externas (ex: APIs, controllers)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ web/
‚îÇ   ‚îÇ        ‚îî‚îÄ‚îÄ controller/              #    ‚îî‚îÄ‚îÄ Controladores REST ou HTTP que iniciam os casos de uso
‚îÇ   ‚îî‚îÄ‚îÄ out/                              # ‚Ü™Ô∏è Sa√≠da: comunica com sistemas externos (ex: banco de dados, servi√ßos)
‚îÇ       ‚îî‚îÄ‚îÄ persistence/
‚îÇ              ‚îî‚îÄ‚îÄ repository/            #    ‚îî‚îÄ‚îÄ Implementa√ß√µes de persist√™ncia (ex: JPA, Mongo, JDBC)
‚îÇ
‚îú‚îÄ‚îÄ application/                          # üß† L√≥gica de aplica√ß√£o (casos de uso e orquestra√ß√£o)
‚îÇ   ‚îú‚îÄ‚îÄ domain/                           #    üîÅ N√∫cleo da aplica√ß√£o (sem depend√™ncias externas)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/                      #     ‚öôÔ∏è Implementa√ß√µes dos casos de uso (ex: CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ model/                        #       Entidades de neg√≥cio e regras do dom√≠nio
‚îÇ   ‚îî‚îÄ‚îÄ ports/                            #    üö™ Interfaces que definem os contratos da aplica√ß√£o
‚îÇ       ‚îú‚îÄ‚îÄ in/                           #       ‚Ü©Ô∏è Portas de entrada: contratos dos casos de uso
‚îÇ       ‚îî‚îÄ‚îÄ out/                          #       ‚Ü™Ô∏è Portas de sa√≠da: contratos com infraestrutura (repos, servi√ßos)
‚îÇ
‚îú‚îÄ‚îÄ common/
```

Vejo aqui um problema conceitual:

-   Domain dentro da pasta application - Quebra o conceito hier√°rquico, dom√≠nio n√£o √© aplica√ß√£o
    Separe dom√≠nio e aplica√ß√£o em pastas distintas seria o ideal
-   Pasta service dentro do domain na aplica√ß√£o. Confunde servi√ßo de dom√≠nio com servi√ßo de aplica√ß√£o. Deve-se separar os servi√ßos de dom√≠nio e servi√ßos de aplica√ß√£o claramente

Vamos ver mais uma estrutura:

A estrutura 3 j√° traz um estilo mais alinhado com DDD (Domain-Driven Design) + Clean Architecture, onde:

-   O projeto √© modularizado por dom√≠nios ou features (ex: m√≥dulo user)
-   Tem camadas bem definidas e com nomes bem expl√≠citos: domain (regras de neg√≥cio puras), application (casos de uso), infrastructure (implementa√ß√µes concretas, adaptadores).
-   √â uma forma mais robusta, clara para sistemas maiores e com m√∫ltiplos dom√≠nios, que facilita modulariza√ß√£o e manuten√ß√£o.

## üü® Estrutura 3 com `domain` , `application` e `infrastructure`

-   Domain = Core: Regras de neg√≥cio puras, modelos do neg√≥cio. O "cora√ß√£o" do sistema.
-   Application: Camada que usa o dom√≠nio para realizar tarefas, orquestra casos de uso, interage com o mundo externo e infraestrutura.
-   Core: Palavra usada para enfatizar o dom√≠nio como o n√∫cleo independente, o "cora√ß√£o" que n√£o depende de nada

![Arquitetura Hexagonal](./docs/image/domaplInf.png)

Reflete os n√≠veis l√≥gicos da aplica√ß√£o (dom√≠nio ‚Üí aplica√ß√£o ‚Üí infraestrutura).
Facilita a visualiza√ß√£o da separa√ß√£o de responsabilidades (DDD + Hexagonal + Clean Architecture)
Adapta-se melhor √† modulariza√ß√£o por dom√≠nio, caso o sistema cres√ßa.
Mais flex√≠vel para projetos reais

### O que faz o Domain (Dom√≠nio) de forma simples?

O Domain √© o lugar onde ficam as regras de neg√≥cio verdadeiras ‚Äî ou seja, as regras do problema real que o sistema resolve.Ele representa o que o neg√≥cio exige, independentemente de tecnologia, interface ou banco de dados.Aqui ficam as entidades, seus comportamentos, e regras que garantem que o neg√≥cio funcione direito.
Exemplo:
No dom√≠nio voc√™ ter√°:
Cliente que sabe se est√° ativo ou n√£o.
Pedido que sabe quando pode ser confirmado.

### O que faz a Application (Aplica√ß√£o) de forma simples?

A Application organiza a l√≥gica de uso do sistema, ou seja, ela diz como as regras de neg√≥cio do dom√≠nio s√£o usadas para realizar tarefas.Ela controla o fluxo, chama os objetos do dom√≠nio, interage com bancos, servi√ßos externos, e prepara dados para a interface.
N√£o cont√©m regras do neg√≥cio, mas sim orquestra o processo para cumprir um caso de uso.
Exemplo:
Na aplica√ß√£o voc√™ ter√°:
Um servi√ßo que recebe uma requisi√ß√£o para criar pedido, verifica dados, chama o dom√≠nio para criar o pedido e grava no banco.
Ela garante que tudo aconte√ßa na ordem certa.

```text
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java               # üöÄ Classe principal que inicia a aplica√ß√£o Spring Boot
‚îÇ
‚îú‚îÄ‚îÄ user/                                   # üßç M√≥dulo de Usu√°rio (Feature modularizada isoladamente)
‚îÇ   ‚îú‚îÄ‚îÄ domain/                             # üß† N√∫cleo do dom√≠nio do usu√°rio (regra de neg√≥cio pura)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ entities/                          # üì¶ Entidades do dom√≠nio (ex: Usuario.java)
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ application/                        # üí° Camada de aplica√ß√£o (orquestra os casos de uso)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/                           #     üö™ Portas: interfaces que exp√µem (input) e consomem (output) funcionalidades
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/                      #       ‚Ü©Ô∏è Casos de uso oferecidos ao mundo externo (ex: CriarUsuarioUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/                     #       ‚Ü™Ô∏è Contratos com servi√ßos externos (ex: UsuarioRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/                        #     ‚öôÔ∏è Implementa√ß√µes dos casos de uso (ex: CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/                            #     üì§ Objetos de transfer√™ncia de dados (ex: CreateUsuarioDTO, UpdateUsuarioDTO)
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/                     # üõ†Ô∏è Implementa√ß√µes concretas de acesso externo (adaptadores e configura√ß√µes)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/                        #     üîå Adaptadores conectando o dom√≠nio com o mundo externo
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/                  #       üåê Adaptadores de entrada (ex: REST Controllers)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UsuarioController.java  #         ‚Üí Recebe requisi√ß√µes HTTP e chama os casos de uso
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/         #       üóÑÔ∏è Adaptadores de sa√≠da (ex: banco de dados, via JPA)
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioRepositoryAdapter.java #   ‚Üí Implementa a interface de reposit√≥rio definida na camada de aplica√ß√£o
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ encoder/, email/                #     üîê Servi√ßos externos (ex: codificador de senha, envio de e-mail)
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ mapper/                             # üîÑ Conversores entre entidades, DTOs e objetos de persist√™ncia
‚îÇ       ‚îî‚îÄ‚îÄ UsuarioMapper.java
‚îÇ
‚îú‚îÄ‚îÄ shared/                                 # üì¶ C√≥digo gen√©rico e reutiliz√°vel entre m√≥dulos
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ (DatabaseConfig.java, BeanConfig.java) # ‚öôÔ∏è Configura√ß√µes globais da aplica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ exception/                                 # ‚ùó Tratamento de exce√ß√µes gen√©ricas da aplica√ß√£o
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GlobalExceptionHandler.java
‚îÇ   ‚îî‚îÄ‚îÄ util/                                      # üß∞ Utilit√°rios diversos compartilhados entre m√≥dulos

```

No DDD cl√°ssico, domain representa o n√∫cleo do neg√≥cio, com entidades, agregados e regras puras.
O nome model vem da tradi√ß√£o MVC (Model-View-Controller) e significa "modelo de dados". Algumas pessoas usam model para representar entidades do dom√≠nio. Termo vago, misturado com conceito MVC tradicional. Mas em arquiteturas baseadas em DDD, o termo mais adequado √© "entities", "domain model" ou simplesmente "domain".

Resumo das vantagens dessa estrutura:
Altamente did√°tica: cada camada e m√≥dulo tem seu espa√ßo e responsabilidade.
Organiza√ß√£o modular (por feature): permite escalar para v√°rios dom√≠nios como account/, product/, etc.
Segrega√ß√£o limpa entre dom√≠nio, aplica√ß√£o e infraestrutura.
Facilita testes, manuten√ß√£o e colabora√ß√£o entre times.

Essas diferen√ßas de nomenclatura e organiza√ß√£o entre as estruturas s√£o bem comuns e refletem varia√ß√µes do mesmo conceito b√°sico da Arquitetura Hexagonal, adaptadas para diferentes estilos, objetivos e n√≠veis de maturidade do projeto.

### ‚úÖ Estrutura Modular por M√≥dulo / Feature ( m√≥dulo User)

```text
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java
‚îú‚îÄ‚îÄ user/                              # üßç M√≥dulo de Usu√°rio
‚îÇ   ‚îú‚îÄ‚îÄ domain/                        # ‚Üê CORE do m√≥dulo usu√°rio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/ (Usuario.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/ (CriarUsuarioUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/ (UsuarioRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/ (CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/ (UsuarioController.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioRepositoryAdapter.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntity.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ encoder/, email/
‚îÇ   ‚îî‚îÄ‚îÄ mapper/ (UsuarioMapper.java)
‚îÇ
‚îú‚îÄ‚îÄ shared/                            # üì¶ C√≥digo compartilhado (se necess√°rio)
‚îÇ   ‚îú‚îÄ‚îÄ config/ (DatabaseConfig.java, BeanConfig.java)
‚îÇ   ‚îú‚îÄ‚îÄ exception/ (GlobalExceptionHandler.java)
‚îÇ   ‚îî‚îÄ‚îÄ util/
```

-   **Modulariza√ß√£o por m√≥dulo de neg√≥cio (ex: `user`)**: Cada m√≥dulo √© praticamente um "mini hex√°gono" isolado, com seu pr√≥prio dom√≠nio, aplica√ß√£o e infraestrutura.
-   **Foco na organiza√ß√£o modular**: Tudo referente ao usu√°rio fica dentro do m√≥dulo `user/`.
-   **Separa claramente as camadas dentro do m√≥dulo**:

    -   `domain/` (modelo e regras do dom√≠nio do usu√°rio)
    -   `application/` (casos de uso, servi√ßos, portas)
    -   `infrastructure/` (adaptadores de entrada e sa√≠da, implementa√ß√µes concretas)

-   **`shared/` para c√≥digo comum entre m√≥dulos** (configura√ß√µes, utilit√°rios, exce√ß√µes globais)

**Resumo:** Organiza√ß√£o por m√≥dulos de neg√≥cio (exemplo: m√≥dulo `user`), onde cada m√≥dulo √© auto-contido e tem as camadas hexagonais internamente.

### ‚úÖ Estrutura com M√≥dulos: `user` e `account`

```text
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java
‚îú‚îÄ‚îÄ user/                              # üßç M√≥dulo de Usu√°rio
‚îÇ   ‚îú‚îÄ‚îÄ domain/                        # ‚Üê CORE do m√≥dulo usu√°rio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/ (Usuario.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/ (CriarUsuarioUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/ (UsuarioRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/ (CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/ (UsuarioController.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioRepositoryAdapter.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntity.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ encoder/, email/
‚îÇ   ‚îî‚îÄ‚îÄ mapper/ (UsuarioMapper.java)
‚îÇ
‚îú‚îÄ‚îÄ account/                           # üè¶ M√≥dulo de Conta Banc√°ria
‚îÇ   ‚îú‚îÄ‚îÄ
‚îÇ
‚îú‚îÄ‚îÄ shared/                            # üì¶ C√≥digo compartilhado (se necess√°rio)
‚îÇ   ‚îú‚îÄ‚îÄ config/ (DatabaseConfig.java, BeanConfig.java)
‚îÇ   ‚îú‚îÄ‚îÄ exception/ (GlobalExceptionHandler.java)
‚îÇ   ‚îî‚îÄ‚îÄ util/
```

Deste que utizemos a invers√£o de depend√™ncia podemos estruturar as pastas da nossa maneira.

-   Core (Dom√≠nio): √© o cora√ß√£o da aplica√ß√£o. N√£o conhece o banco, nem o Spring. Cont√©m a l√≥gica pura.
-   Application Layer: orquestra os casos de uso. Usa interfaces (ports) para se comunicar com o mundo externo.
-   Infrastructure: √© o mundo externo ‚Äî onde ficam os detalhes concretos (Web, Banco de Dados, Email...).
-   Adapters: ligam o mundo externo (Infra) ao core, implementando as interfaces da camada de aplica√ß√£o.

### Estrutura Separa√ß√£o por Camadas Globais sem modulariza√ß√£o expl√≠cita

Separa√ß√£o maior de responsabilidades. Aqui temos o dom√≠nio rico, com a regras de neg√≥cio separada da aplica√ß√£o.

```bash
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java          # Classe principal (Spring Boot)
‚îÇ
‚îú‚îÄ‚îÄ domain/                            # üí† N√∫cleo (Dom√≠nio - Core do Hex√°gono)
‚îÇ   ‚îú‚îÄ‚îÄ model/                         # ‚Üí Entidades do dom√≠nio (regras e estado)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Usuario.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Email.java
‚îÇ   ‚îú‚îÄ‚îÄ exception/                     # ‚Üí Exce√ß√µes do dom√≠nio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DomainException.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UsuarioNotFoundException.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ EmailJaExisteException.java
‚îÇ   ‚îî‚îÄ‚îÄ service/                       # ‚Üí Regras de neg√≥cio do dom√≠nio
‚îÇ       ‚îî‚îÄ‚îÄ UsuarioDomainService.java
‚îÇ
‚îú‚îÄ‚îÄ application/                       # üí° Camada de Aplica√ß√£o (Casos de Uso)
‚îÇ   ‚îú‚îÄ‚îÄ port/                          # ‚Üí Portas (interfaces para entrada/sa√≠da)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/                     # ‚Ü™ Input Ports (Interfaces de casos de uso)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CriarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BuscarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AtualizarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InativarUsuarioUseCase.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/                    # ‚Ü™ Output Ports (interfaces para depend√™ncias)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioRepositoryPort.java
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ EmailServicePort.java
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PasswordEncoderPort.java
‚îÇ   ‚îú‚îÄ‚îÄ service/                       # ‚Üí Implementa√ß√µes dos casos de uso
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CriarUsuarioService.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BuscarUsuarioService.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AtualizarUsuarioService.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InativarUsuarioService.java
‚îÇ   ‚îî‚îÄ‚îÄ dto/                           # ‚Üí Objetos de transfer√™ncia de dados
‚îÇ       ‚îú‚îÄ‚îÄ UsuarioDTO.java
‚îÇ       ‚îú‚îÄ‚îÄ CreateUsuarioCommand.java
‚îÇ       ‚îî‚îÄ‚îÄ UpdateUsuarioCommand.java
‚îÇ
‚îú‚îÄ‚îÄ infrastructure/                   # üõ†Ô∏è Infraestrutura (Adapters + Configura√ß√µes)
‚îÇ   ‚îú‚îÄ‚îÄ adapter/                      # ‚Üí Adaptadores concretos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/                    # ‚Ü™ Adaptadores Prim√°rios (ex: Web)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ web/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioController.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ GlobalExceptionHandler.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/                   # ‚Ü™ Adaptadores Secund√°rios (Banco, Email...)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ persistence/
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ UsuarioJpaRepository.java
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ UsuarioRepositoryAdapter.java
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ entity/
‚îÇ   ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntity.java
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ encoder/
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ BCryptPasswordEncoderAdapter.java
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ email/
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ EmailServiceAdapter.java
‚îÇ   ‚îú‚îÄ‚îÄ config/                       # ‚Üí Configura√ß√µes (Beans, JPA, etc)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BeanConfiguration.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DatabaseConfig.java
‚îÇ   ‚îî‚îÄ‚îÄ mapper/                       # ‚Üí Conversores (domain <-> entity/dto)
‚îÇ       ‚îú‚îÄ‚îÄ UsuarioMapper.java
‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntityMapper.java

```

-   **Estrutura cl√°ssica da Arquitetura Hexagonal em camadas globais**, n√£o modularizada por features:

    -   `domain/` ‚Äî n√∫cleo do dom√≠nio com entidades, exce√ß√µes, servi√ßos de dom√≠nio
    -   `application/` ‚Äî casos de uso, portas, DTOs, servi√ßos de aplica√ß√£o
    -   `infrastructure/` ‚Äî adaptadores e configura√ß√µes gerais da infraestrutura

-   **Todas as entidades e servi√ßos do dom√≠nio ficam numa pasta √∫nica `domain/`**
-   **Todos os casos de uso e servi√ßos de aplica√ß√£o tamb√©m ficam em `application/`**
-   **Adaptadores de entrada e sa√≠da est√£o organizados dentro da pasta `infrastructure/`**
-   **Separa√ß√£o mais tradicional e ampla, menos modular**

**Resumo:** Organiza√ß√£o em camadas horizontais globais, onde cada camada √© √∫nica e engloba toda a aplica√ß√£o.

### Principais diferen√ßas resumidas

| Aspecto              | Estrutura B√°sica Modular                             | Estrutura Completa em Camadas Globais                        |
| -------------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| Organiza√ß√£o          | Por m√≥dulos (ex: m√≥dulo user)                        | Por camadas (domain, application, infrastructure)            |
| Isolamento           | Cada m√≥dulo tem dom√≠nio, aplica√ß√£o e infra separadas | Dom√≠nio, aplica√ß√£o e infra s√£o globais para toda a aplica√ß√£o |
| Reuso entre m√≥dulos  | Usa `shared/` para componentes comuns                | C√≥digo comum fica em camadas (ex: config, mappers) globais   |
| Escalabilidade       | Facilita crescimento com v√°rios m√≥dulos              | Pode ficar mais dif√≠cil escalar com muitos recursos          |
| Complexidade inicial | Pode ser mais complexa inicialmente                  | Estrutura mais simples para projetos pequenos                |
| Manuten√ß√£o           | Boa para times grandes e m√∫ltiplos dom√≠nios          | Melhor para projetos pequenos ou m√©dios                      |

---

### Quando usar cada uma?

-   **Modular** ‚Äî Projetos maiores, com muitos dom√≠nios/m√≥dulos, times trabalhando separadamente.
-   **Estrutura Separa√ß√£o por Camadas Globais** ‚Äî Projetos menores, prot√≥tipos, quando a equipe √© pequena e o dom√≠nio n√£o precisa ser muito fragmentado.

### 2.2 Compara√ß√£o: 3 Camadas vs Hexagonal

| Aspecto           | 3 Camadas                         | Hexagonal                            |
| ----------------- | --------------------------------- | ------------------------------------ |
| **Acoplamento**   | Controller ‚Üí Service ‚Üí Repository | Ports ‚Üî Adapters                     |
| **Depend√™ncias**  | Camadas dependem de frameworks    | Core independe de tudo               |
| **Testabilidade** | Mocks complexos                   | Mocks simples (interfaces)           |
| **Flexibilidade** | Mudan√ßas afetam m√∫ltiplas camadas | Mudan√ßas isoladas em adapters        |
| **Complexidade**  | Menor (inicial)                   | Maior (inicial), menor (longo prazo) |

---

# Implementa√ß√£o

Em contru√ß√£o

# Pr√≥ximos passos:

## Parte 3: Modularizar e criar novos m√≥dulos

### Nova Estrutura

√ìtima pergunta! Se voc√™ for **modularizar** a aplica√ß√£o (ex: separando os dom√≠nios `user` e `account`), o ideal √© **isolar a responsabilidade de cada m√≥dulo**, mantendo **a Arquitetura Hexagonal** em cada um, como se cada dom√≠nio fosse uma mini-aplica√ß√£o dentro do projeto.

---

### ‚úÖ Estrutura com M√≥dulos: `user` e `account`

```text
src/main/java/com/exemplo/hexagonal/
‚îú‚îÄ‚îÄ HexagonalApplication.java
‚îú‚îÄ‚îÄ user/                              # üßç M√≥dulo de Usu√°rio
‚îÇ   ‚îú‚îÄ‚îÄ domain/                        # ‚Üê CORE do m√≥dulo usu√°rio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/ (Usuario.java)      # üîÅ N√∫cleo do dom√≠nio (entidades e regras puras)
‚îÇ       ‚îú‚îÄ‚îÄ service/                   # Servi√ßos de dom√≠nio (regra de neg√≥cio complexa)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/
‚îÇ   ‚îú‚îÄ‚îÄ application/                             # üß† Casos de uso / orquestra√ß√£o da aplica√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/                                 # Interfaces de entrada e sa√≠da (contratos)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/ (CriarUsuarioUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/ (UsuarioRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/ (CriarUsuarioService.java)   # Implementa√ß√£o dos casos de uso (ex: CriarUsuarioService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/                            # üõ†Ô∏è Implementa√ß√£o concreta (adaptadores, persist√™ncia, etc)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/ (UsuarioController.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UsuarioRepositoryAdapter.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ UsuarioEntity.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ encoder/, email/
‚îÇ   ‚îî‚îÄ‚îÄ mapper/ (UsuarioMapper.java)
‚îÇ
‚îú‚îÄ‚îÄ account/                           # üè¶ M√≥dulo de Conta Banc√°ria
‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/ (Conta.java, Transacao.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/ (AbrirContaUseCase.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/ (ContaRepositoryPort.java)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/ (AbrirContaService.java)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/web/ (ContaController.java)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/persistence/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ContaRepositoryAdapter.java
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ContaEntity.java
‚îÇ   ‚îî‚îÄ‚îÄ mapper/ (ContaMapper.java)
‚îÇ
‚îú‚îÄ‚îÄ shared/                            # üì¶ C√≥digo compartilhado (se necess√°rio)
‚îÇ   ‚îú‚îÄ‚îÄ config/ (DatabaseConfig.java, BeanConfig.java)
‚îÇ   ‚îú‚îÄ‚îÄ exception/ (GlobalExceptionHandler.java)
‚îÇ   ‚îî‚îÄ‚îÄ util/
```

A estrutura modularizada por funcionalidade (como user/, account/) √© mais did√°tica, mais clara para aprender, escalar e manter, especialmente quando voc√™ est√° explicando para alunos ou iniciando em projetos maiores.

---

### üí° Benef√≠cios dessa modulariza√ß√£o:

| Vantagem                           | Explica√ß√£o                                              |
| ---------------------------------- | ------------------------------------------------------- |
| **Separa√ß√£o de responsabilidades** | `user` cuida de usu√°rios, `account` cuida de contas     |
| **Reutiliza√ß√£o**                   | Voc√™ pode mover um m√≥dulo para outro projeto, se quiser |
| **Facilidade de testes**           | Cada m√≥dulo pode ser testado isoladamente               |
| **Escalabilidade**                 | Pode evoluir cada m√≥dulo de forma independente          |

---

# Conhecimentos: Dom√≠nio an√™mico e rico

√ìtima observa√ß√£o! Voc√™ apontou um ponto muito comum e importante no desenvolvimento de software: **por que algumas entidades (como essa classe `Usuario`) s√£o "puras" s√≥ com dados e valida√ß√µes t√©cnicas, mas n√£o t√™m regras de neg√≥cio expl√≠citas?**

Vou explicar as raz√µes principais para isso e o que isso significa no contexto de arquitetura limpa e DDD:

---

## 1. **Essa classe `Usuario` √© um _Entity_ "an√™mica"**

-   O c√≥digo que voc√™ mostrou √© um exemplo cl√°ssico do que chamamos de **Anemic Domain Model** (Modelo de Dom√≠nio An√™mico).
-   √â uma entidade que cont√©m **apenas atributos (dados) e algumas valida√ß√µes t√©cnicas**, mas quase nenhuma regra de neg√≥cio embutida nela.
-   Essa pr√°tica √© muito comum em projetos que usam JPA/Hibernate porque:

    -   O foco √© mapear diretamente para o banco de dados (ORM)
    -   As regras de neg√≥cio acabam ficando fora da entidade, geralmente em servi√ßos ou camadas de aplica√ß√£o.

---

## 2. **Por que isso acontece?**

-   **Separa√ß√£o de preocupa√ß√µes vs praticidade:**
    As entidades JPA precisam ser simples para funcionar bem com o ORM, muitas vezes isso faz os desenvolvedores colocarem regras fora da entidade.
-   **Falta de aplica√ß√£o estrita de DDD:**
    Nem todo projeto segue os princ√≠pios de DDD puro onde as entidades carregam comportamento e regras do neg√≥cio. Muitos projetos s√£o mais ‚ÄúCRUD-centric‚Äù (focados em criar, ler, atualizar e deletar dados).
-   **Valida√ß√µes t√©cnicas embutidas:**
    As anota√ß√µes `@NotBlank`, `@Email` e etc s√£o para validar o formato e integridade dos dados, n√£o s√£o regras do neg√≥cio.
-   **Regras de neg√≥cio est√£o em outro lugar:**
    Normalmente, as regras como "Usu√°rio s√≥ pode ser inativado se n√£o tiver pend√™ncias" ficariam em servi√ßos de dom√≠nio ou na camada de aplica√ß√£o.

---

## 3. **Qual o problema dessa abordagem?**

-   Essa ‚Äúanemia‚Äù pode fazer seu modelo de dom√≠nio **ficar muito fraco**, pois as regras ficam dispersas, dificultando a manuten√ß√£o, evolu√ß√£o e teste.
-   Voc√™ perde a vantagem de encapsular regras junto com os dados, que √© um dos pilares do DDD.

---

## 4. **Quando usar entidades com comportamento?**

-   Quando quiser que o dom√≠nio reflita fielmente o neg√≥cio, a entidade deve conter comportamentos (m√©todos) que **garantem as regras de neg√≥cio**, e n√£o s√≥ dados.
-   Exemplo:

    ```java
    public class Usuario {
        private Boolean ativo = true;
        // ...
        public void inativar() {
            if (temPendencias()) {
                throw new BusinessException("Usu√°rio n√£o pode ser inativado com pend√™ncias");
            }
            this.ativo = false;
        }
        // m√©todo que verifica regra de neg√≥cio
        private boolean temPendencias() {
            // l√≥gica para verificar pend√™ncias
        }
    }
    ```

---

## 5. **Resumo**

| Aspecto                       | Entidade ‚Äúan√™mica‚Äù (exemplo dado)                   | Entidade rica em comportamento (DDD puro)             |
| ----------------------------- | --------------------------------------------------- | ----------------------------------------------------- |
| Cont√©m                        | Apenas dados e valida√ß√µes t√©cnicas                  | Dados + regras de neg√≥cio e comportamento             |
| Onde ficam regras de neg√≥cio? | Em servi√ßos ou aplica√ß√£o                            | Dentro da pr√≥pria entidade/domain                     |
| Vantagem                      | F√°cil para CRUD simples e integra√ß√£o com ORM        | Dom√≠nio expressivo, regras encapsuladas, mais robusto |
| Desvantagem                   | Dom√≠nio fraco, regras dispersas, dif√≠cil manuten√ß√£o | Pode ser mais complexo para iniciar, exige disciplina |
